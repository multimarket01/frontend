import { ConnectedPosition } from '@angular/cdk/overlay';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { AfterViewInit, ChangeDetectorRef, DoCheck, EventEmitter, OnInit, TemplateRef } from '@angular/core';
import { ControlValueAccessor, FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { Select2AutoCreateEvent, Select2Data, Select2Group, Select2Option, Select2RemoveEvent, Select2ScrollEvent, Select2SearchEvent, Select2SelectionOverride, Select2UpdateEvent, Select2UpdateValue } from './select2-interfaces';
import * as i0 from "@angular/core";
export declare class Select2 implements ControlValueAccessor, OnInit, DoCheck, AfterViewInit {
    protected _viewportRuler: ViewportRuler;
    private _changeDetectorRef;
    private _parentForm;
    private _parentFormGroup;
    _control: NgControl;
    _data: Select2Data;
    /** data of options & optiongrps */
    set data(data: Select2Data);
    minCharForSearch: number;
    displaySearchStatus: 'default' | 'hidden' | 'always';
    placeholder: string;
    limitSelection: number;
    listPosition: 'above' | 'below' | 'auto';
    get multiple(): boolean;
    set multiple(value: boolean);
    /** use the material style */
    overlay: boolean;
    /** use the material style */
    styleMode: 'material' | 'noStyle' | 'borderless' | 'default';
    /** message when no result */
    noResultMessage: string;
    /** maximum results limit (0 = no limit) */
    maxResults: number;
    /** message when maximum results */
    maxResultsMessage: string;
    /** infinite scroll distance */
    infiniteScrollDistance: number;
    /** infinite scroll distance */
    infiniteScrollThrottle: number;
    /** infinite scroll activated */
    infiniteScroll: boolean;
    /** auto create if not exist */
    autoCreate: boolean;
    /** no template for label selection */
    noLabelTemplate: boolean;
    /** use it for change the pattern of the filter search */
    editPattern: (str: string) => string;
    /** template(s) for formatting */
    templates: TemplateRef<any> | {
        [key: string]: TemplateRef<any>;
    };
    /** template for formatting selected option */
    templateSelection: TemplateRef<any>;
    /** the max height of the results container when opening the select */
    resultMaxHeight: string;
    /** Active Search event */
    customSearchEnabled: boolean;
    /** minimal data of show the search field */
    get minCountForSearch(): number;
    set minCountForSearch(value: number);
    /** Unique id of the element. */
    get id(): string;
    set id(value: string);
    /** Whether the element is required. */
    required: boolean;
    /** Whether selected items should be hidden. */
    get disabled(): boolean;
    set disabled(value: boolean);
    /** Whether items are hidden when has. */
    hideSelectedItems: boolean;
    /** Whether the element is readonly. */
    readonly: boolean;
    /** The input element's value. */
    get value(): Select2UpdateValue;
    set value(value: Select2UpdateValue);
    /** Tab index for the select2 element. */
    get tabIndex(): number;
    set tabIndex(value: number);
    /** reset with no selected value */
    resettable: boolean;
    /** selected value when × is clicked */
    resetSelectedValue: any;
    /** grid: item by line
     * * 0 = no grid
     * * number = item by line (4)
     * * string = minimal size item (100px)
     */
    grid: string;
    /**
     * Replace selection by a text
     * * if string: `%size%` = total selected options
     * * if function: juste show the string
     */
    selectionOverride: Select2SelectionOverride;
    /** force selection on one line */
    selectionNoWrap: boolean;
    /** Add an option to select or remove all (if all is selected) */
    showSelectAll: boolean;
    /** Text for remove all options */
    removeAllText: string;
    /** Text for select all options */
    selectAllText: string;
    update: EventEmitter<Select2UpdateEvent<Select2UpdateValue>>;
    autoCreateItem: EventEmitter<Select2AutoCreateEvent<Select2UpdateValue>>;
    open: EventEmitter<Select2>;
    close: EventEmitter<Select2>;
    focus: EventEmitter<Select2>;
    blur: EventEmitter<Select2>;
    search: EventEmitter<Select2SearchEvent<Select2UpdateValue>>;
    scroll: EventEmitter<Select2ScrollEvent>;
    removeOption: EventEmitter<Select2RemoveEvent<Select2UpdateValue>>;
    option: Select2Option | Select2Option[] | null;
    isOpen: boolean;
    searchStyle: string;
    /** Whether the element is focused or not. */
    focused: boolean;
    filteredData: import("@angular/core").WritableSignal<Select2Data>;
    get select2Options(): Select2Option[];
    get select2Option(): Select2Option;
    get searchText(): string;
    set searchText(text: string);
    get ariaInvalid(): boolean;
    get classMaterial(): boolean;
    get classNostyle(): boolean;
    get classBorderless(): boolean;
    get select2above(): boolean;
    overlayWidth: number;
    overlayHeight: number;
    _triggerRect: DOMRect;
    _dropdownRect: DOMRect;
    get _positions(): ConnectedPosition[];
    maxResultsExceeded: boolean;
    private _minCountForSearch?;
    private cdkConnectedOverlay;
    private selection;
    private resultContainer;
    private results;
    private searchInput;
    private dropdown;
    private hoveringValue;
    private innerSearchText;
    private isSearchboxHidden;
    private selectionElement;
    private get resultsElement();
    private _stateChanges;
    /** Tab index for the element. */
    private _tabIndex;
    private _disabled;
    private _multiple;
    private _id;
    private _uid;
    private _value;
    private _previousNativeValue;
    private _overlayPosition;
    constructor(_viewportRuler: ViewportRuler, _changeDetectorRef: ChangeDetectorRef, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, _control: NgControl, tabIndex: string);
    clickDetection(e: MouseEvent): void;
    /** View -> model callback called when select has been touched */
    private _onTouched;
    /** View -> model callback called when value changes */
    private _onChange;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngDoCheck(): void;
    updateSearchBox(): void;
    hideSearch(): boolean;
    getOptionStyle(option: Select2Option): string;
    mouseenter(option: Select2Option): void;
    click(option: Select2Option): void;
    reset(event?: MouseEvent): void;
    prevChange(event: Event): void;
    stopEvent(event: Event): void;
    toggleOpenAndClose(focus?: boolean, open?: boolean, event?: KeyboardEvent): void;
    hasTemplate(option: Select2Option | Select2Group, defaultValue: string, select?: boolean): boolean;
    getTemplate(option: Select2Option | Select2Group, defaultValue: string, select?: boolean): any;
    triggerRect(): void;
    isNumber(o: any): boolean;
    selectAll(): void;
    selectAllTest(): boolean;
    private testSelection;
    private testValueChange;
    private updateFilteredData;
    private clickExit;
    private ifParentContainsClass;
    private ifParentContainsId;
    private getParentElementByClass;
    private getParentElementById;
    private containClasses;
    private containAlmostOneClasses;
    private clickOnSelect2Element;
    focusin(): void;
    focusout(): void;
    select(option: Select2Option | null, emit?: boolean): void;
    private testDiffValue;
    keyDown(event: KeyboardEvent, create?: boolean): void;
    openKey(event: KeyboardEvent, create?: boolean): void;
    searchUpdate(e: Event): void;
    trackBy(_index: number, item: Select2Option): any;
    isSelected(option: Select2Option): "true" | "false";
    isDisabled(option: Select2Option): "true" | "false";
    removeSelection(e: MouseEvent | KeyboardEvent, option: Select2Option): void;
    /**
     * Sets the model value. Implemented as part of ControlValueAccessor.
     * @param value
     */
    writeValue(value: any): void;
    /**
     * Saves a callback function to be invoked when the select's value
     * changes from user input. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param fn Callback to be triggered when the value changes.
     */
    registerOnChange(fn: (value: any) => void): void;
    /**
     * Saves a callback function to be invoked when the select is blurred
     * by the user. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param fn Callback to be triggered when the component has been touched.
     */
    registerOnTouched(fn: () => void): void;
    /**
     * Sets whether the component should be disabled.
     * Implemented as part of ControlValueAccessor.
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean): void;
    onScroll(way: 'up' | 'down'): void;
    _isErrorState(): boolean;
    _selectionOverrideLabel(): string;
    private optionsSize;
    private addItem;
    private createAndAdd;
    private moveUp;
    private moveDown;
    private updateScrollFromOption;
    private selectByEnter;
    private _testKey;
    private _getKey;
    private _isKey;
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    private _setSelectionByValue;
    /** Does some manual dirty checking on the native input `value` property. */
    private _dirtyCheckNativeValue;
    private _focusSearchboxOrResultsElement;
    private _focus;
    private _isAbobeOverlay;
    static ɵfac: i0.ɵɵFactoryDeclaration<Select2, [null, null, { optional: true; }, { optional: true; }, { optional: true; self: true; }, { attribute: "tabindex"; }]>;
    static ɵcmp: i0.ɵɵComponentDeclaration<Select2, "select2", never, { "data": { "alias": "data"; "required": true; }; "minCharForSearch": { "alias": "minCharForSearch"; "required": false; }; "displaySearchStatus": { "alias": "displaySearchStatus"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "limitSelection": { "alias": "limitSelection"; "required": false; }; "listPosition": { "alias": "listPosition"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "overlay": { "alias": "overlay"; "required": false; }; "styleMode": { "alias": "styleMode"; "required": false; }; "noResultMessage": { "alias": "noResultMessage"; "required": false; }; "maxResults": { "alias": "maxResults"; "required": false; }; "maxResultsMessage": { "alias": "maxResultsMessage"; "required": false; }; "infiniteScrollDistance": { "alias": "infiniteScrollDistance"; "required": false; }; "infiniteScrollThrottle": { "alias": "infiniteScrollThrottle"; "required": false; }; "infiniteScroll": { "alias": "infiniteScroll"; "required": false; }; "autoCreate": { "alias": "autoCreate"; "required": false; }; "noLabelTemplate": { "alias": "noLabelTemplate"; "required": false; }; "editPattern": { "alias": "editPattern"; "required": false; }; "templates": { "alias": "templates"; "required": false; }; "templateSelection": { "alias": "templateSelection"; "required": false; }; "resultMaxHeight": { "alias": "resultMaxHeight"; "required": false; }; "customSearchEnabled": { "alias": "customSearchEnabled"; "required": false; }; "minCountForSearch": { "alias": "minCountForSearch"; "required": false; }; "id": { "alias": "id"; "required": false; }; "required": { "alias": "required"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "hideSelectedItems": { "alias": "hideSelectedItems"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "value": { "alias": "value"; "required": false; }; "tabIndex": { "alias": "tabIndex"; "required": false; }; "resettable": { "alias": "resettable"; "required": false; }; "resetSelectedValue": { "alias": "resetSelectedValue"; "required": false; }; "grid": { "alias": "grid"; "required": false; }; "selectionOverride": { "alias": "selectionOverride"; "required": false; }; "selectionNoWrap": { "alias": "selectionNoWrap"; "required": false; }; "showSelectAll": { "alias": "showSelectAll"; "required": false; }; "removeAllText": { "alias": "removeAllText"; "required": false; }; "selectAllText": { "alias": "selectAllText"; "required": false; }; }, { "update": "update"; "autoCreateItem": "autoCreateItem"; "open": "open"; "close": "close"; "focus": "focus"; "blur": "blur"; "search": "search"; "scroll": "scroll"; "removeOption": "removeOption"; }, never, ["select2-label", "select2-hint"], false, never>;
    static ngAcceptInputType_minCharForSearch: unknown;
    static ngAcceptInputType_limitSelection: unknown;
    static ngAcceptInputType_multiple: unknown;
    static ngAcceptInputType_overlay: unknown;
    static ngAcceptInputType_maxResults: unknown;
    static ngAcceptInputType_infiniteScrollDistance: unknown;
    static ngAcceptInputType_infiniteScrollThrottle: unknown;
    static ngAcceptInputType_infiniteScroll: unknown;
    static ngAcceptInputType_autoCreate: unknown;
    static ngAcceptInputType_noLabelTemplate: unknown;
    static ngAcceptInputType_customSearchEnabled: unknown;
    static ngAcceptInputType_minCountForSearch: unknown;
    static ngAcceptInputType_required: unknown;
    static ngAcceptInputType_disabled: unknown;
    static ngAcceptInputType_hideSelectedItems: unknown;
    static ngAcceptInputType_readonly: unknown;
    static ngAcceptInputType_tabIndex: unknown;
    static ngAcceptInputType_resettable: unknown;
    static ngAcceptInputType_selectionNoWrap: unknown;
    static ngAcceptInputType_showSelectAll: unknown;
}
//# sourceMappingURL=select2.component.d.ts.map